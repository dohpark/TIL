## 데크 (Deque)

- Double-Ended Queue 약자로, 삽입과 삭제가 양쪽 끝에서 모두 발생할 수 있는 선형 자료 구조
- 구현 메서드

  - 데이터 전체 획득 / 비어 있는지 확인: Deque.getBuffer(), Deque.isEmpty()
  - 데이터 추가 / 삭제: Deque.pushFront(), Deque.popFront(), Deque.pushBack(), Deque.popBack()
  - 첫번째 & 끝 데이터 반환 / 사이즈 / 전체 삭제: Deque.front(), Deque.back(), Deque.size(), Deque.clear()

- 앞 뒤 모두 push pop을 할 수 있는 것이 특징

## 데크 구현(1)

- `Deque()`: 초기 속성값 설정을 위한 생성자 함수
- `getBuffer()`: 객체 내 데이터 셋 반환
- `isEmpty()`: 데이터 비어 있는지 확인

```javascript
// Deque()
function Deque(array = []) {
  this.array = array;
}

// getBuffer()
Deque.prototype.getBuffer = function () {
  return this.array.slice();
};

// isEmpty()
Deque.prototype.isEmpty = function () {
  return this.array.length === 0;
};

let dq = new Deque([1, 2, 3]);
console.log(dq); // Deque { array: [ 1, 2, 3 ] }

let data = dq.getBuffer();
console.log(data === dq.array); // false
console.log(data); // [ 1, 2, 3 ]

console.log(dq.isEmpty()); // false
console.log(Object.getOwnPropertyDescriptors(Deque.prototype));
/*
{
  constructor: {
    value: [Function: Deque],
    writable: true,
    enumerable: false,
    configurable: true
  },
  getBuffer: {
    value: [Function (anonymous)],
    writable: true,
    enumerable: true,
    configurable: true
  },
  isEmpty: {
    value: [Function (anonymous)],
    writable: true,
    enumerable: true,
    configurable: true
  }
}
*/
```

## 데크 구현(2)

- `pushFront()`: 앞쪽 데이터 추가
- `popFront()`: 앞쪽 데이터 삭제
- `pushBack()`: 뒤쪽 데이터 추가
- `popBack()`: 뒤쪽 데이터 삭제

```javascript
// pushFront()
Deque.prototype.pushFront = function (element) {
  return this.array.unshift(element); // 기존 메서드 사용
};

// popFront()
Deque.prototype.popFront = function () {
  return this.array.shift(); // 기존 메서드 사용
};

// pushBack()
Deque.prototype.pushBack = function (element) {
  return this.array.push(element); // 기존 메서드 사용
};

// popBack()
Deque.prototype.popBack = function () {
  return this.array.pop(); // 기존 메서드 사용
};

let dq = new Deque([1, 2, 3]);
console.log(dq); // Deque { array: [ 1, 2, 3 ] }

dq.pushFront(0);
dq.pushBack(4);
console.log(dq); // Deque { array: [ 0, 1, 2, 3, 4 ] }

console.log(dq.popFront()); // 0
console.log(dq.popBack()); // 4
console.log(dq); // Deque { array: [ 1, 2, 3 ] }
```

## 데크 구현(3)

- `front()`: 가장 첫 데이터 반환
- `back()`: 가장 끝 데이터 번환
- `size()`: 큐 내 데이터 개수 확인
- `clear()`: 큐 초기화

```javascript
// front()
Deque.prototype.front = function () {
  return this.array.length === 0 ? undefined : this.array[0]; // length로 존재하는지 확인 후 반환
};

// back()
Deque.prototype.back = function () {
  return this.array.length === 0
    ? undefined
    : this.array[this.array.length - 1];
}; // length로 존재하는지 확인 후 있을 시에 마지막 값 반환

// size()
Deque.prototype.size = function () {
  return this.array.length;
};

// clear()
Deque.prototype.clear = function () {
  this.array = [];
};

let dq = new Deque([1, 2, 3]);
console.log(dq); // Deque { array: [ 1, 2, 3 ] }

console.log(dq.front()); // 1
console.log(dq.back()); // 3
console.log(dq.size()); // 3

dq.clear();
console.log(dq); // Deque { array: [] }
```

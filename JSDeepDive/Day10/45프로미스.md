## 프로미스

- 콜백헬과 에러 처리의 곤란으로 ES6에서 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입함

### 비동기 처리를 위한 콜백 패턴의 단점

- 콜백 헬

  - 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료됨.
  - 비동기 함수가 종료된 이후에 비동기 함수 내부의 비동기로 동작하는 코드가 완료되기에, 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않음.
  - 비동기로 동작하는 코드는 태스크 큐에 저장되어 대기하다가, 콜 스택이 비면 이벤트 루프에 의해 콜 스택으로 푸시되어 실행됨.
  - 이 때문에 기대하는대로 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당할 때 아직 비동기로 동작하는 코드는 아직 태스크 큐에서 대기하는 중일 수도 있음.
  - 따라서 비동기 함수의 처리 결과(서버의 응답 등)에 대한 후속 처리는 비동기 함수 내부에서 수행해야함.
  - 이때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 일반적임.
  - 비동기 처리 결과에 대한 후속 처리를 다시 콜백 함수를 계속 중첩적으로 전달하여 코드의 복잡도가 높아지는 현상을 콜백 헬이라고 부름.

- 에러 처리의 한계

  - try... catch문에서 try에 비동기 함수를 작성하고, 비동기 함수의 콜백 함수에 에러를 강제로 발생할 것임.
  - try문의 비동기 함수가 에러를 내도 catch문은 실행되지 않음.
  - 비동기 함수는 콜백 함수가 실행되어 에러를 발생하기 전에 이미 종료(콜 스택에서 제거가된 상태)가 됨.
  - 콜백 함수는 태스크 큐로 푸시되어 이벤트 루프에 의해 콜 스택이 비어졌을 때 콜 스택으로 푸시되어 실행됨.
  - 즉, 콜 스택 상 콜백함수를 호출한 것은 비동기 함수가 아니게 된 것임.
  - 에러는 호출자 방향으로 전파되어, 콜 스택의 아래 방향으로 전파되는데 기존 비동기 함수가 콜백 함수를 호출한 것이 아니게되어 catch 블럭이 에러를 캐치하지 못한 것임.

### 프로미스의 생성

- Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성함.
- ES6에서 도입된 Promise는 ECMAScript 사양에 정의된 표준 빌트인 객체임
- Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받음.
- Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행함. 비동기 처리가 성공하면 resolve함수를 호출하고, 실패하면 reject 함수를 호출함.
- 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체임
- 비동기 처리 상태
  - 프로미스는 현재 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 정보를 가짐.
  - 생성된 직후의 프로미스는 기본적으로 pending 상태이며, 비동기 처리 결과에 따라 프로미스의 상태가 변경됨.
  - pending이 아닌 상태를 settled 상태(fulfilled or rejected)라고 함.

| 프로미스의 상태 정보 | 의미                                  | 상태 변경 조건                   |
| -------------------- | ------------------------------------- | -------------------------------- |
| pending              | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
| fulfilled            | 비동기 처리가 수행된 상태(성공)       | resolve 함수 호출                |
| rejected             | 비동기 처리가 수행된 상태(실패)       | reject 함수 호출                 |

- 비동기 처리 결과
  - 프로미스는 비동기 처리 결과도 상태로 가짐.
  - fulfilled 상태면 비동기 처리 결과인 1을 값으로 가짐. rejected 상태면 비동기 처리 결과인 Error격체를 값으로 가짐.

### 프로미스의 후속 처리 메서드

- 프로미스 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출됨.

- `Promise.prototype.then`

  - then 메서드는 두개의 콜백 함수를 인수로 전달받음
    - 첫번째 콜백 함수는 프로미스가 fulfilled 상태가 되면 호출됨. 이 때 then 메서드의 콜백함수는 프로미스의 비동기 처리 결과를 인수로 전달받음
    - 두번째 콜백 함수는 프로미스가 rejected 상태가 되면 호출됨. 이 때 then 메서드의 콜백함수는 흐로미스의 에러를 인수로 전달받음.
  - then 메서드는 언제나 프로미스를 반환함
  - 만약 then 메서드의 콜백 함수가 프로미스를 반환하면 그 프로미스를 그대로 반환함
  - 만약 then 메서드의 콜백 함수가 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성해 반환함.

- `Promise.prototype.catch`

  - catch 메서드는 한 개의 콜백 함수를 인수로 전달받음.
  - catch 메서드의 콜백 함수는 프로미스가 rejected 상태인 경우만 호출됨
  - then 메서드와 마찬가지로 언제나 프로미스를 반환함

- `Promise.prototype.finally`

  - finally 메서드는 한개의 콜백 함수를 인수로 전달받음.
  - finally 메서드의 콜백 함수는 프로미스의 성공 실패 상관없이 무조건 한번 호출됨.
  - then 메서드와 마찬가지로 언제나 프로미스를 반환함.

### 프로미스의 에러 처리

- 비동기 처리에서 발생한 에러는 프로미스의 후속 처리 메서드 catch를 사용해 처리할 수 있음
- catch 메서드를 호출하면 내부적으로 then(undefined, onRejected를 호출함
- then 메서드의 두번째 콜백 함수는 첫번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져서 가독성이 좋지않음
- catch 메서드를 모든 then 메서드에 호출한 이후에 호출하면 비동기 처리에서 발생한 에러뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치함
- 또한 then 메서드에 두번째 콜백 함수를 전달하는 것보다 catch 메서드를 사용하는 것이 가독성이 좋고 명확함
- 에러처리는 then 메서드에서 하지 말고 catch 메서드에서 하는 것을 권장함.

### 프로미스 체이닝

- 프로미스는 then, catch, finally 후속 처리 메서드를 통해 콜백 헬을 해결할 수 있음
- then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있음. 이를 프로미스 체이닝이라고 함.
- 콜백 헬은 발생하지 않지만 콜백 패턴을 사용하기에 가독성이 좋지 않음
- 이는 async/await를 통해 해결할 수 있음.

### 프로미스의 정적 메서드

- Promise.resolve / Promise.reject

  - Promise.resolve와 Promise.reject 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용함
  - Promise.resolve 메서드는 인수로 전달받은 값을 resolve하는 프로미스를 생성함.
  - Promise.reject 메서드는 인수로 전달받은 값을 rejecte하는 프로미스를 생성함.

- Promise.all

  - Promise.all 메서드는 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용함
  - 서로 의존하지 않고 개별적으로 수행되기에 비동기 처리를 순차적으로 처리할 필요가 없음
  - Promise.all 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받음. 전달받은 모든 프로미스가 fulfilled 상태가 되면 모든 처리 결과를 배열에 저장해 새로운 프로미스를 반환함.
  - 배열에 저장할 때 첫번째 프로미스가 resolve한 처리 결봐부터 차례대로 저장해 처리 순서가 보장됨.
  - Promise.all 메서드는 인수로 전달받은 배열의 프로미스가 하나라도 rejected 상태가 되면 나머지 프로미스의 상태와 상관없이 즉시 종료함.
  - Promise.all 메서드는 인수로 전달받은 이터러블의 요소가 프로미스가 아닌 경우 Promise.resolve 메서드를 통해 프로미스로 래핑함.

- Promise.race

  - Promise.race 메서드는 Promise.all 메서드와 동일하게 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받음
  - Promise.race 메서드는 Promise.all 메서드처럼 모든 프로미스가 fulfilled 상태가 되는 것을 기다리는 것이 아니라 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 새로운 프로미스를 반환함.
  - Promise.race 메서드에 전달된 프로미스가 하나라도 rejected 상태가 되면 Promise.all 메서드와 마찬가지로 에러를 reject하는 새로운 프로미스를 즉시 반환함.

- Promise.allSettled

  - ES11에 도입됨
  - Promise.allSettled 메서드는 프로미스를 요소로 갖는 배열등의 이터러블을 인수로 전달받음.
  - 전달받은 프로미스가 모두 settled 상태가 되면 처리 결과를 배열로 반환함.
  - 프로미스가 fulfilled 상태인 경우 비동기 처리 상태를 나타내는 status 프로퍼티와 처리 결과를 나타내는 value 프로퍼티를 가짐
  - 프로미스가 rejected 상태인 경우 비동기 처리 상태를 나타내는 status 프로퍼티와 에러를 나타내는 reason 프러퍼티를 가짐

### 마이크로태스크 큐

- 태스크 큐와 별도로 마이크로태스크 큐가 존재함
- 마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시저장됨
- 태스크 큐에는 비동기 함수의 콜백 함수나 이벤트 핸들러가 저장됨.
- 마이크로태스크 큐는 태스크큐보다 우선순위가 높음.
- 이벤트 루프는 콜 스택이 비면 우선 마이크로태스크 큐에서 대기하는 함수를 가져와 실행함. 마이크로태스크 큐가 비면 태스크 큐에서 대기하는 함수를 가져와 실행함.

### fetch

- fetch 함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 WebAPI임.
- fetch 함수는 XMLHttpRequest 객체보다 사용법이 간단하며 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유로움
- fetch 함수는 HTTP 요청을 전송할 URL과 HTTP 요청 메서드, HTTP 요청 헤더, 페이로드 등을 설정한 객체를 전달함.
- `fetch(url [, options])`
- fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환함.
- Response 객체는 HTTP 응답을 나타내는 다양한 프로퍼티를 제공함.
- Response.prototype에는 Response 객체에 포함되어 있는 HTTP 응답 몸체를 위한 다양한 메서드를 제공함.

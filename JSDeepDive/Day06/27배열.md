## 배열

### 배열이란?

- 배열이 가지고 있는 값을 요소라고 부름
- 자바스크립트의 모든 값(원시값, 객체, 함수, 배열 등)은 배열의 요소가 될 수 있음
- 배열의 요소는 배열에서 자신의 위치를 나타내는 0이상의 정수인 인덱스를 가짐.
- 요소에 접근하고자 할때 대괄호 표기법을 쓰며, 대괄호 내에 접근하고 싶은 요소의 인덱스를 지정하면 됨.
- 배열은 요소의 개수 or 배열의 길이를 나타내는 length 프로퍼티를 가짐. 인덱스와 length 프로퍼티 덕분에 for문을 통해 순차적으로 요소에 접근 가능함.
- 배열은 객체타입임. 배열 타입이란 존재하지 않음
- 배열은 배열 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있음.
- 배열의 생성자 함수는 Array, 배열의 프로토타입 객체는 Array.prototype.
- 객체와 배열의 가장 큰 차이는 값의 순서와 length 프로퍼티임. 배열은 이 둘 덕분에 순차적으로 값에 접근하기 적합한 자료구조임.

### 자바스크립트 배열은 배열이 아니다

- 일반적으로 자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말함.
- 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있음. 이런 배열을 밀집 배열이라고 함.
- 밀집배열은 인덱스를 통해 임의의 요소에 접근할 때 매우 효율적이나, 특정한 요소 검색, 삭제 등을 할 때 비효율적임.
- 자바스크립트 배열은 희소배열로 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않을 수 있으며, 연속적으로 이어져 있지 않을 수 있음
- 자바스크립트의 배열은 배열을 흉내 낸 특수한 객체임. 자바스크립트의 배열은 인덱스는 프로퍼티 키, 배열의 요소는 프로퍼티 값, length 프로퍼티를 지니는 객체임.
- 자바스크립트 배열은 해시 테이블로 구현된 객체이므로, 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인면에서 느리지만, 특정한 요소 검색, 삽입, 삭제 경우 더 빠른 성능이 나올 수 있음

### length 프로퍼티와 희소 배열

- length 프로퍼티는 0이상 2의 32승 미만의 양의 정수임.
- length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제하면 자동 갱신됨.
- length 프로퍼티 값은 배열의 길이를 바탕으로 결정되지만 임의의 숫자 값을 명시적으로 할당할 수 있음.
- 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어듬
- 현재 length 프로퍼티 값보다 큰 숫자 값을 할당하면 배열의 길이가 늘어나지 않음. empty라고 console창에 표시되지만 실제 배열 내를 Object.getOwnProperty Descriptors 메서드로 들여다 보면 아무런 변함이 없음을 볼 수 있음
- 이처럼 희소 배열은 length와 배열의 요소의 개수가 일치하지 않으며, 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 큼.
- 자바스크립트는 희소 배열을 문법적으로 허용하나 배열의 기본적인 개념과 맞지 않으며, 성능에도 부정적인 영향을 쭈기에 권장하지 않음.

### 배열 생성

- 배열 리터럴

  - 가장 일반적이고 간편한 배열 생성 방식
  - 0 개 이상의 요소를 쉽표로 구분하여 대괄호([])로 묶음. 객체 리터럴과 달리 프로퍼티 키가 없고, 값만 존재함
  - 요소를 추가하지 않으면 배열의 길이(length 프로퍼티값)이 0인 빈 배열이 됨
  - 요소를 생략하면 희소 배열이 생성됨 ex const arr = [1, , 3];
  - 위 희소배열은 인덱스가 1인 요소를 갖지 않음. `arr[1]`이 undefined인 이유는 arr 프로퍼티 키가 1인 프로퍼티가 존재하지 않기 때문임.

- Array 생성자 함수

  - 전달되 인수가 1개이고 숫자인 경우 length 프로퍼티 값이 인수인 배열을 생성함

    - 이 때 생성된 배열은 희소 배열임. length 프로퍼티 값은 0이 아니지만 실제로 배열의 요소는 존재하지 않음
    - 배열은 요소를 최대 2의 32승 -1개 가질 수 있음. 만약에 해당 범위를 벗어나면 RangeError가 발생함

  - 전달된 인수가 없는 경우 빈 배열을 생성함

  - 전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성함

    - Array 생성자 함수는 new 연산자와 함께 호출하지 않더라도, 일반 함수로서 호출해도 배열을 생성하는 생성자 함수로 동작함. 이는 Array 생성자 함수 내부에서 new.target을 확인하기 때문임.

- Array.of

  - ES6부터 도입함.
  - 전달된 인수를 요소로 갖는 배열을 생성함.
  - Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성함.

- Array.from

  - ES6부터 도입됨.
  - 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환함
  - ex. Array.from({ length: 2, 0: 'a', 1: 'b'}) // => ['a', 'b']. Array.from('hi') // => ['h', 'i']
  - 두번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있음
  - 콜백 함수의 첫번째 인수는 배열의 요소값, 두번째 인수는 인덱스를 말함.
  - ex. Array.from({ length: 3 }, (val, i) => i) // => [0, 1, 2]

### 배열 요소의 참조

- 배열의 요소를 참조할 때 대괄호([]) 표기법을 사용함. 대괄호 안에는 인덱스가 와야함.
- 정수로 평가되는 표현식이라면 인덱스 대신 사용할 수 있음
- 객체의 프로퍼티 키와 같은 역할을 함
- 존재하지 않는 요소에 접근하면 undefined가 반환됨. (이는 일반 객체에서도 마찬가지임). 그렇기에 희소 배열의 존재하지 않는 요소를 참조해도 undefined가 반환됨.

### 배열 요소의 추가와 갱신

- 배열에도 요소를 동적으로 추가할 수 있음. 존재하지 않는 인덱스를 통해 값을 할당하면 새로운 요소가 추가되며, length 프로퍼티 값은 자동으로 갱신됨.
- 혅재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 됨.
- 요소가 존재하는 요소에 값을 재할당하면 요소값이 갱신됨.
- 인덱스에 0 이상의 정수 or 정수 형태의 문자열을 사용해야함.
- 만약 정수 이외의 값을 인덱스처럼 사용하면 요소가 생성되는 것이 아닌 프로퍼티가 생성됨. 이때 추가된 프로퍼티는 length 프로퍼티 값에 영향을 주지 않음.

### 배열 요소의 삭제

- 배열의 특정 요소를 삭제하기 위해 delete 연산자를 사용할 수 있음
- delete 연산자는 객체의 프로퍼티를 삭제하기에 프로퍼티 키 포함 값 모두 삭제한다.
- delete 연산자로 삭제 시에 희소배열이 될 수 있기에 delete 연산자 사용을 권장하지 않음.

### 배열 메서드

- 배열 메서드는 원본 배열을 직접 변경하는 메서드(mutator method)와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드(accessor method)로 나뉨.
- mutator method는 부수효과를 일으키기에 주의해야하므로 accessor 메서드를 사용하는 편이 좋음

- Array.isArray

  - Array 생성자 함수의 정적 메서드
  - 배열이면 true 반환, 아니면 false 반환

- Array.prototype.indexOf

  - 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환함
  - 원본 배열에 인수로 전달한 요소와 중복되는 요소가 여러개 있는 경우 첫번째로 검색된 요소의 인덱스를 반환함.
  - 존재하지 않으면 -1 반환
  - indexOf 메서드 대신 존재유무 확인이 필요할때 Array.prototype.includes 메서드 사용 추천함.

- Array.prototype.push

  - 원본 배열의 마지막 요소로 인수로 전달받은 모든 값을 추가하고 변경된 length 프로퍼티 값을 반환함
  - push 메서드는 성능 면에서 좋지않아, length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가하는 방법이 더 빠름.
  - push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있기에, 스프레드 문법을 사용하여 함수 호출 없이 표현식 마지막 요소에 요소 추가하는 방법을 추천함. ex. const newArr = [...arr, 3] // 기존 arr의 요소들에 3을 추가한 배열을 생성함

- Array.prototype.pop

  - 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환함.
  - 원본 배열이 빈 배열이면 undefined를 반환함.

- Array.prototype.unshift

  - 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환함.
  - 원본 배열을 직접 변경하는 부수 효과가 있음.
  - 부수 효과가 있기에 사용을 권장하지 않고 스프레드 문법을 통해 추가하는 방법을 고려하셈

- Array.prototype.shift

  - 첫번째 요소를 제거하고 제거한 요소를 반환함.
  - 원본 배열이 빈 배열이면 undefined를 반환함.

- Array.prototype.concat

- Array.prototype.splice

- Array.prototype.slice

- Array.prototype.join

- Array.prototype.reverse

- Array.prototype.fill

- Array.prototype.includes

- Array.prototype.flat

### 배열 고차 함수

- Array.prototype.sort

- Array.prototype.forEach

- Array.prototype.map

- Array.prototype.filter

- Array.prototype.reduce

- Array.prototype.some

- Array.prototype.every

- Array.prototype.find

- Array.prototype.findIndex

- Array.prototype.flatMap

## 전역 변수의 문제점

### 변수의 생명주기

- 지역 변수의 생명주기

  - 변수는 생성되고 소멸되는 생명주기가 있음.
  - 전역 변수의 생명주기는 어플리케이션의 생명주기와 같음
  - 함수 내부에 선언된 지역변수는 함수 호출 시 생성하고 함수 종료 시 소멸됨. 즉 함수의 생명 주기와 일치함.
  - 지역 변수가 함수보다 오래 생존하는 경우도 있는데, 이는 누군가가 해당 스코프를 참조하고 있어 가비지 콜렉터에 의해 해제되지 않는 상태일 때 발생함.
  - 호이스팅은 함수 단위로 동작함. 그래서 함수 내에서도 지역변수 호이스팅을 볼 수가 있음.

- 전역 변수의 생명주기

  - var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨. 즉 전역변수의 생명주기는 전역 객체의 생명주기와 같음.
  - 브라우저 환경에서 전역 객체는 window이므로 웹페이지를 닫기 전까지 전역객체와 전역브라우저가 유효함.

### 전역 변수의 문제점

- 암묵적 결합

  - 전역변수는 모든 코드가 전역변수를 참조할 수 있기에 암묵적 결합을 허용함. 이는 에러 가능성을 높여서 안 좋음.

- 긴 생명주기

  - 생명주기가 길기에 메모리 리소스를 오랜 기간 소비함.

- 스코프 체인 상에서 종점에 존재

  - 가장 마지막에 검색되기에 전역 변수의 검색 속도가 가장 느림

- 네임스페이스 오염

  - 파일 분리되어도 전역 스코프를 공유해서 예상치 못한 결과를 가져옴.

### 전역 변수의 사용을 억제하는 방법

- 즉시 실행함수

  - 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 지역 변수가 됨. ㄴㅇㄱ
  - 라이브러리 등에 사용됨

- 네임스페이스 객체

  - 네임스페이스 역할의 객체를 만들어 전역변수처럼 사용하고자 하는 변수를 프로퍼티로 추가하는 방법
  - 그러나 네임스페이스 객체 또한 전역 변수에 할당되어 유용하지는 않음.

- 모듈 패턴

  - 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만드는 방법
  - 클로저를 활용하여 전역 변수를 억제함.
  - 캡슐화(프로퍼티와 메서드를 하나로 묶는 것)를 통해 정보 은닉 가능
  - js는 public, private, protected등의 접근 제한자를 제공하지 않아 캡슐화를 통해 이와 비슷하게 만들 수 있음.

- ES6 모듈

  - ES6 모듈 사용시 파일 자체의 독자적인 모듈 스코프를 제공함.
  - script 태그에 type="module" 어트리뷰트 추가하면 js파일은 모듈로 동작함. 확장자는 mjs를 권장.
  - 구형에는 동작하지 않기에 webpack의 모듈 번들러를 사용하는 것이 일반적.

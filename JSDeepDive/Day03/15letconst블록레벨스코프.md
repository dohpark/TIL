## let, const 키워드와 블록 레벨 스코프

### var 키워드로 선언한 변수의 문제점

- 변수 중복 선언 허용

  - var 키워드로 선언한 변수는 다시 var 키워드로 중복 선언해도 동작함.
  - 다만 초기화문이 있는 변수 선언문은 var 키워드 없는 것처럼 동작하고
  - 초기화문이 없는 변수 선언문은 아예 무시됨.

- 함수 레펠 스코프

  - 함수의 코드블록만 지역 스코프로 인정하고 그 외는 인정하지 않음.
  - 그 때문에 의도치 않게 전역 변수가 중복 선언될 수 있음

- 변수 호이스팅
  - var 키워드로 선언시 변수 호이스팅으로 인해 변수 선언문이 스코프 가장 위로 끌어 올린것처럼 동작함
  - 가독성을 떨어트려 오류 발생 가능성을 높임.

### let 키워드

- 변수 중복 선언 금지

  - var 키워드로 중복 선언시 에러가 발생하지 않지만, let 키워드로 중복선언시 문법에러(SyntaxError)가 발생함.

- 블록 레벨 스코프

  - var 키워드로 선언한 변수는 함수 레벨 스코프를 따르지만, let 키워드로 선언한 변수는 블록 레벨 스코프를 따름(함수, if문, for문, try/catch 등을 포함)
  - 함수도 코드블록이므로 스코프를 만듬. 함수 내의 코드 블록은 함수 레벨 스코프에 중첩됨.

- 변수 호이스팅

  - var 키워드로 선언한 변수는 선언단계에서 렉시컬 환경에 변수 식별자 등록하고, 즉시 초기화 단계에서 undefined로 변수를 초기화함.
  - let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행됨. 선언단계가 먼저 실행되고, 변수 선언문에 도달했을 때 초기화 단계를 진행함.
  - 초기화 단계 이전에 참조할려고 하면 참조 에러(Reference Error)가 발생함. 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal Dead Zone)이라 부름.
  - let 키워드도 여전히 호이스팅은 발생함. 그 이유는 선언단계가 런타임 이전에 실행되기 때문임. 다만 할당을 안했기에 호이스팅이 발생하지 않은 것처럼 동작함.

- 전역 객체와 let

  - var 키워드로 선언한 전역 변수, 전역함수, 암묵적 전역은 객체 window의 프로퍼티가 됨. 전역객체의 프로퍼티를 참조할때 window를 생략할 수 있음.
  - let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니기에 window로 접근할 수 없음. let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 됨.

### const 키워드

- 상수를 선언하기 위해 사용함.

- 선언과 초기화

  - const 키워드로 선언한 변수는 선언과 동시에 초기화 해야함.
  - 안그럼 문법에러(Syntax Error)가 발생함.
  - 블록 레벨 스코프를 가지며, 호이스팅이 발생하지 않는것처럼 동작함.

- 재할당 금지

  - const 키워드로 선언한 변수는 재할당이 금지됨.

- 상수

  - const 키워드로 선언한 변수에 원시 값을 할당한 경우 할당된 값을 변경할 수 있는 방법이 없음.
  - 일반적으로 상수임을 표시하기 위해 대문자로 선언하고, 스네이크 케이스로 표현하는 것이 일반적임.

- const 키워드와 객체

  - const 키워드로 선언한 변수에 객체를 할당한 경우 값을 변경할 수 있음.
  - const는 재할당이 금지된 것뿐, 불변을 의미하지 않음.

### var vs. let vs. const

- 우선 const 키워드 사용 후 재할당 필요할시 let으로 변경하는 것을 권장함.

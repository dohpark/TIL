## 함수

### 함수란

- 함수는 자바스크립트의 핵심 개념으로 매우 중요함.
- `함수`란 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것.
- `매개변수`란 함수 내부로 입력을 전달받는 변수
- `인수`란 매개변수를 통해 입력하는 값
- `반환값`이란 함수를 실행하여 얻는 값
- 함수는 `함수정의`(function defintion)을 통해 생성함
- `함수호출`이란 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시한 것. 함수호출을 통해 얻은 실행값을 반환값.

### 함수를 사용하는 이유

- 함수는 여러번 호출할 수 있기에 반복적이고 중복적인 작업 수행할때 미리 정의된 함수를 여러번 호출하여 쉽게 해결할 수 있음. 즉 코드의 재사용면에서 매우 유용함.
- 코드의 중복을 억제하여 유지보수의 편의성을 높이고, 코드의 신뢰성을 높일 수 있음.
- 함수 이름(식별자)에 역할을 설명할 수 있는 이름을 붙이면 코드의 가독성을 높일 수 있음.

### 함수 리터럴

- 함수는 객체 타입의 값!
- 함수 또한 리터럴로 생겅 가능함.
- 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성.

- 함수 이름

  - 식별자. 식별자 네이밍 규칙을 준수해야함.
  - 함수 몸체 내에서만 참조할 수 있음.
  - 함수 이름 생략 가능. 이름 유: 기명함수(named function). 이름 무: 무명/익명함수(anonymous function)

- 매개변수 목록

  - 0개 이상, 소괄호로 감쌈, 쉽표로 구분
  - 순서에 의미가 있음
  - 함수 몸체 내에서 변수로 취급하기에 식별자 네이밍 규칙을 준수해야함

- 함수 몸체

  - 실행 단위로 정의한 코드블록
  - 함수 호출에 의해 실행됨

- 함수 리터럴은 값을 생성하기 위한 표기법임. 함수리터럴은 평가되고 객체 값을 생성함.
- 그러나 함수는 일반객체와 다르게 호출을 할 수가 있음. 또한, 일반 객체에는 없는 고유한 프로퍼티를 지니고 있음.

### 함수정의

- 함수 정의란 인수를 전달 받을 매개변수, 실행할 문들, 반환할 값을 지정하는 것.
- 정의된 함수는 js엔진에 의해 평가되어 함수 객체가 됨.
- 정의 방식은 4가지가 있음

  - 함수 선언문
  - 함수 표현식
  - Function 생성자 함수
  - 화살표 함수

- 함수선언문

  - 함수 선언문은 표현식이 아닌 문.
  - 함수 선언문과 함수 리터럴의 차이는 형태가 아니라, JS엔진이 어떻게 해석하느냐에 따라 차이가 나타남.
  - 비슷한 예시. {}은 블록문일 수도 객체 리터럴일수도 있음. 둘을 어떻게 구분하냐면 객체 리터럴은 값으로 평가되는 문맥이고, {}은 아님.
  - 이와 비슷하게 함수 리터럴을 단독으로 사용하면 함수선언문이 되고, 값으로 평가해야 할때 함수 리터럴 표현식으로 해석됨.
  - 예제 12-8. 그룹 연산자() 내에 있는 함수 리터럴은 그룹 연산자의 피연산자로 값으로 평가될 수 있기에 표현식이 됨. 따라서 함수선언문(표현식이 아닌 문)은 피연산자로 사용할 수 없음.
  - 함수 선언문과 함수 리터럴 표현식은 호출에 차이가 있음. 함수 리터럴 표현식은 호출할 수 없고, 함수 선언문은 호출할 수 있음.
  - 함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자임. 그 뜻은 외부에서 함수이름으로 호출할 수 없다는 것. 식별자가 없다는 것과 같음.
  - 함수 선언문의 함수 이름 또한 함수 몸체 내에서만 유효함. 그러나 자바스크립트 엔진이 암묵적으로 식별자를 생성해서 이를 통해 호출이 가능함.
  - 자바스크립트 엔진이 함수 선언문으로 생성한 함수를 호출 할 수 있도록 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함.
  - 즉 함수 선언문은 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함.
  - 결론적으로 JS엔진이 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한 것.

- 함수 표현식

  - JS함수는 일급 객체임. 일급 객체란 값의 성질을 갖는 객체라는 뜻.
  - 그 덕분에 함수를 변수에 할당 가능, 프로퍼티 값이 될 수 있고, 배열의 요소가 될 수 있음.
  - 함수 객체를 변수에 할당하여 정의한 방식을 함수 표현식이라고 함.
  - 주의해야할게 만약에 식별자(변수)에 할당한 기명함수의 경우, 해당 함수 이름으로 호출하면 Reference 에러가 날거임. 식별자 이름으로 호출해야함.
  - 왜냐하면 함수 이름은 함수 몸체 내부에서만 유효한 식별자이기 때문임.

- 함수 생성시점과 호이스팅

  - 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점은 다름.
  - 함수 선언문은 런타임 이전에 JS엔진에 의 실행되어, 함수 객체를 생성하고 함수 이름과 같은 이름의 식별자를 생성한 뒤 해당 함수 객체를 할당함.
  - 그 덕분에 코드 상 함수 선언문 이전에 함수를 참조하고 호출할 수 있음. 이를 함수 호이스팅이라고 부름.
  - 함수 호이스팅은 변수 호이스팅이라 다름. 변수 호이스팅은 var 키워드로 선언한 변수가 undefined로 초기화된 것이고, 함수 선언문은 암묵적으로 생성된 식별자에 함수 객체로 초기화함.
  - 함수 표현식의 경우, 변수 선언으로 undefined가 초기화 되지만 변수 할당문이 실행되는 시점(런타임 때)에 평가되어 함수 객체가 됨.
  - 함수 호이스팅 문제 때문에 함수 선언문 대신 함수 표현식을 사용할 것을 권장함.

- Function 생성자 함수

  - new 연산자 또는 없이 호출이 가능함.
  - 함수 생성방식이 일방적이지 않고 권장하지 않음. (클러저를 생성하지 않음)

- 화살표 함수

  - function 키워드 대신 화살표 =>를 통해 함수를 선언하는 방법.
  - 항상 익명 함수로 정의함.
  - 내부 동작이 간략화 됨(this 바인딩, prototype 프로퍼티가 없음, arguments 객체 생성하지 않음)

### 함수호출

- 함수 호출 시 checkDistance(25, 30), 함수를 가리키는 식별자(checkDistance)와 함수호출 연산자 ()로 호출함.
- 함수호출 연산자 () 내에는 0개 이상의 인수를 쉼표로 구분해서 나열함.
- 함수 호출 시 현재 실행흐름을 중단하고 호출된 함수로 실행 흐름을 옮기며, 매개변수에 인수가 순서대로 할당되고, 함수 몸체의 문들이 실행됨.

- 매개변수와 인수

  - 함수 외부에서 내부로 값을 전달해야할때, 매개변수(parameter)를 통해 인수(argument)를 전달함.
  - 인수는 값으로 평가될 수 있는 표현식. 개수와 타입에 제한없음.
  - 매개변수는 함수를 정의할 때 선언됨. 함수 몸체 내부에서 변부로 취급됨.
  - 그래서 함수 호출시 함수 몸체 내에서 암묵쩍으로 매개변수가 생성되고, undefined 초기화 된수 인수가 순서대로 할당함.
  - 매개변수는 함수 몸체 내부에서만 참조됨. 매개변수의 스코프는 함수 내부.
  - 함수는 매개변수와 인수의 개수가 일치하는지 상관안함. 인수가 부족할시 해당 매개변수에 인수가 할당되지 않아 undefine가 값이 됨.
  - 매개변수보다 인수가 더 많을 때 초과된 인수는 무시됨. 모든 인자는 암묵적으로 arguments 객체의 프로퍼티로 보관되어 버려지지는 않음.
  - 이를 활용하여 가변인자함수(매개변수 개수가 확정할 수 없는 함수) 구현 시 arguments 객체가 사용됨.

- 인수 확인

  - 문제1 자바스크립트는 매개변수와 인수의 개수가 일치하는지 확인하지 않음.
  - 이는 arguments 객체를 통해 인수 개수 확인할 수 있음. 또는 단축평가를 통해 매개변수에 기본값 할당할 수 있음.
  - 또는 매개변수 기본값을 사용할 수 있음

  - 문제2 매개변수의 타입을 사전에 지정할 수 없음
  - 이는 타입스크립트 사용시 해결할수 있음. 또는 조건문과 typeof 연산자를 통해 원하는 데이터타입만 매개변수가 받을 수 있도록 할 수 있음.

- 매개변수의 최대 개수

  - 매개변수가 많을 수록 유지보수성이 나빠지게 적을수록 좋다.
  - 함수는 한가지 일만 해야하기에 가급적 적게 만들자.
  - 객체를 인수로 사용하면 매개변수의 순서를 신경쓰지 않게되어 코드의 가독성이 좋아질 수 있지만, 객체를 함수 내부에서 변경하면 함수 외부의 객체도 변경되는 것을 유의하자.

  - 반환문

    - 반환문은 return 키워드 + 표현식으로 구성됨
    - 역할1 함수실행을 중단하고 함수 몸체를 빠져나감
    - 역할2 return 키워드 뒤에 오는 표현식을 평가해 반환함.
    - 명시적으로 return 키워드 뒤에 표현식이 지정하지 않으면 undefined가 반환됨.
    - 반환문은 생략가능하며 암묵적으로 undefined 반환함.
    - return 키워드와 표현식 사이에 줄바꿈이 있다면 세미콜론 자동삽입 기능에 의해 세미콜론이 추가됨.
    - 반환문은 함수 몸체 내부에서만 사용가능함.

### 참조에 의한 전달과 외부 상태의 변경

- 함수를 호출하며 매개변수에 값을 전달할때 인수가 원시값(primitive)인 경우 값에 의한 전달로 줌. 즉 재할당을 통해 할당된 원시 값을 새로운 원시값으로 교체한것임.
- 객체 타입 인수를 전달 받은 경우 참조에 의한 전달로 줌. 그렇기 때문에 함수 몸체에서 값이 변경되면 원본 또한 변경이 됨.
- 이렇게 되면 상태 변화의 추적이 어려워져 오류가 일어날 가능성이 높아짐.
- 이를 방지하기 위해 객체 변경을 추적하려는 옵저버 패턴 등을 통해 변경 시 알 수 있게 되어 이를 대처할 수 있도록 하거나
- 객체를 불변 객체로 만들어 사용하여 해결할 수도 있음. (객체를 원시값처럼 변경 불가능한 값으로 동작하게 만드는 것.)
- 불변 객체로 만들면 객체의 상태 변경을 원천봉쇄하고 상태 변경이 필요한 경우 객체의 방어적 복사를 통해 깊은 복사를 하여 원시값과 같이 재할당하여 교체.
- 이런 함수를 순수 함수라고 하며, 순수함수를 통해 부수 효과를 최대한 억제하기 위한 패러다임을 함수형 프로그래밍이라고 함.

### 다양한 함수의 형태

- 즉시실행함수(IIFE)

  - 단 한번만 호출되며 다시 호출할 수 없음
  - 함수 리터럴로 평가됨. 그룹 연산자()로 감싸야 에러가 발생하지 않음.
  - 감싸지 않으면 세미콜론 자동삽입 기능 때문에 func() {};();로 실행됨. (중괄호 뒤에 세미콜론이 암묵적으로 추가됨)
  - 뒤의 ()는 그룹 연산자로 해석되는데, () 내에 피연산자가 없기에 에러가 발생함.
  - 즉시실행함수의 형태는 여러가지가 있음.
  - 즉시 실행 함수 내에 코드를 모아 두면 변수나 함수 이름의 충돌을 방지할 수 있음

- 재귀함수

  - 재귀호출(함수가 자기 자신을 호출하는 것)을 수행하는 함수
  - 재귀호출할 때의 식별자는 함수이름으로 함수 몸체 내부에서만 유효함. 함수 이름을 사용해 자기 자신을 호출하는 것.
  - 재귀함수는 탈출 조건을 만들어야함. 안그럼 함수가 무한 호출되어 스택 오버플로 에러가 발생함.
  - 반복문 없이 반복처리를 할 수 있다는 장점이 있지만 스택 오버플로 에러의 위험성이 있음.
  - 그러므로 직관적으로 재귀함수가 반복문보다 필요할 경우 한정적으로 사용해야함.

- 중첩함수

  - 함수 내부에 정의한 함수를 중첩함수(nested function) or 내부함수(inner function)이라고 함. 중첩함수는 헬퍼함수의 역할을 함
  - 중첨함수를 포함하는 함수를 외부함수(outer function)이라고 함.
  - es6부터 if문 또는 for문에 함수를 정의할 수 있지만 호이스팅으로 인해 함수 선언문을 통해 함수를 정희하는 것은 바람직하지 않음.

- 콜백함수

  - 자바스크립트의 함수는 일급 객체이기에 매개변수를 통해 함수를 전달할 수 있음.
  - 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 함.
  - 콜백함수를 전달받은 함수 또는 반환값으로 함수를 반환하는 함수를 고차함수라고 함.
  - 콜백함수는 헬퍼 함수의 역할을 함. 고차함수는 내부로 콜백함수를 주입하여 자신의 일부분으로 합성하기에 콜백함수를 자유롭게 교체 가능함.
  - 콜백함수는 고차함수에 의해 호출되며, 이때 콜백함수에 인수를 전달함. 즉 함수 자체를 전달함.
  - 비동기와 배열고차함수 사용시 콜백함수를 자주 사용함.

- 순수함수와 비순수함수

  - 순수 함수란 외부상태에 의존하지도 않고, 변경하지도 않는, 부수 효과가 없는 함수임.
  - 비순수함수는 부수효과가 있는 함수임.
  - 순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 특징이 있음. (인수에 의존해 반환값을 만듬)
  - 순수함수는 외부상태에 의존하지 않음.

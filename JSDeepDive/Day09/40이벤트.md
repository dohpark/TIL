## 이벤트

### 이벤트 드리븐 프로그래밍

- 이벤트 발생했을 때 호출된 함수를 이벤트 핸들러라고 함
- 이벤트 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라고 함
- 이벤트와 이벤트 핸들러를 통해 사용자와 애플리케이션은 상호작용할 수 있음. 이런 이벤트 중심으로 제어하는 프로그램 방식을 이벤트 드리븐 프로그래밍이라 함.

### 이벤트 타입

- 마우스 이벤트

  - `click`
    - 마우스 버튼 클릭했을 때
  - `dblclick`
    - 마우스 버튼 더블 클릭
  - `mousedown`
    - 마우스 버튼을 눌렀을 때
  - `mouseup`
    - 누르고 있던 마우스 버튼을 놓았을 때
  - `mousemove`
    - 마우스 커서를 움직였을 때
  - `mouseenter`
    - 마우스 커서를 HTML 요소 안으로 이동했을때(버블링 되지 않음)
  - `mouseover`
    - 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 됨)
  - `mouseleave`
    - 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링 되지 않음)
  - `mouseout`
    - 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링 됨)

- 키보드 이벤트

  - `keydown`
    - 모든 키를 눌렀을 때 발생
    - control, option, shift, tab, delete, enter 방향 키와 문자, 숫자, 특수 문자 키를 눌렀을 때 발생
    - 문자, 숫자, 특수문자, enter 키를 눌렀을 때는 연속적으로 발생. 그 외는 한번만 발생
  - `keypress`
    - 문자 키를 눌렀을 때 연속적으로 발생
    - 문자, 숫자, 특수문자, enter 키를 눌렀을 때만 발생
    - deprecated
  - `keyup`
    - 누르고 있던 키를 놓았을 때 한 번만 발생
    - control, option, shift, tab, delete, enter 방향 키와 문자, 숫자, 특수 문자 키를 놓았을 때 발생

- 포커스 이벤트

  - `focus`
    - HTML 요소가 포커스를 받았을 때 (버블링 되지 않음)
  - `blur`
    - HTML 요소가 포커스를 잃었을 때 (버블링되지 않음)
  - `focusin`
    - HTML 요소가 포커스를 받았을 때 (버블링 됨)
  - `focusout`
    - HTML 요소가 포커스를 잃었을 때 (버블링 됨)

- 폼 이벤트

  - `submit`
    - form 요소 내의 submit 버튼을 클릭했을 때
  - `reset`
    - form 요소 내의 reset 버튼을 클릭했을 때 (최근에 사용 안함)

- 값 변경 이벤트

  - `input`
    - input(text, checkbox, radio), select, textarea 요소의 값이 입력되었을 때
  - `change`
    - input(text, checkbox, radio), select, textarea 요소의 값이 변경되었을때
    - change 이벤트는 input과 달리 HTML 요소가 포커스를 잃었을 때 사용자 입력이 종료되었다고 인식하여 발생함.
    - 사용자가 입려하고 있을 때 input 이벤트 발생, 사용자가 입력이 종료되어 값이 변경되면 change 이벤트가 발생함.
  - `readystatechange`
    - HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티 값('loading', 'interactive', 'complete')이 변경될때

- DOM 뮤테이션 이벤트

  - `DOMContentLoaded`
    - HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때

- 뷰 이벤트

  - `resize`
    - 브라우저 윈도우(window)의 크기를 리사이징할 때 연속적으로 발생함(window객체에서만 발생함.)
  - `scroll`
    - 웹페이지(document) 또는 HTML 요소를 스크롤할 때 연속적으로 발생함

- 리소스 이벤트

  - `load`
    - DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료되었을 때 (주로 window 객체에서 발생)
  - `unload`
    - 리소스 언로드될 때 (주로 새로운 웹페이지를 요청한 경우)
  - `abort`
    - 리소스 로딩이 중단되었을 때
  - `error`
    - 리소스 로딩이 실패했을 때

### 이벤트 핸들러 등록

- 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라고 함
- 이벤트 핸들러를 등록하는 방법은 3가지임.

- 이벤트 핸들러 어트리뷰트 방식

  - HTML 요소의 어트리뷰트 중에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 있음.
  - 이벤트 핸들러 어트리뷰트 이름은 on접두사 + 이벤트 타입으로 이루어져 있음 ex. `<button onClick="sayHi('Lee')">Click</button>`
  - 이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문을 할당하면 이벤트 핸들러가 등록됨
  - 이벤트 핸들러 어트리뷰트 값은 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미함.
  - 어트리뷰트는 파싱되어 함수를 암묵적으로 생성하고, 이벤트 핸들러 어트리뷰트 이름과 동일한 이벤트 핸들러 프로퍼티 키에 해당 함수 호출문을 할당함.
  - 이벤트 핸들러 어트리뷰트 값으로 같이 여러 개의 문을 할당할 수 있음
  - 모던 자바스크립트에서는 CBD 방식의 React, Vue등의 프레임워크/라이브러리에서 이벤트 핸들러 어트리뷰트 방식으로 이벤트를 처리함.

- 이벤트 핸들러 프로퍼티 방식

  - window 객체와 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있음.
  - 이벤트 핸들러 프로퍼티 키는 on 접두사 + 이벤트 타입으로 이루어져 있음
  - 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록됨
  - ex. `button.onclick = function () {}` button <= 이벤트 타깃, onclick <= on+이벤트타입, function <= 이벤트 핸들러
  - 이벤트 핸들러는 대부분 이벤트를 발생시킬 이벤트 타깃에 바인딩 하지만, 전파된 이벤트를 캐치할 DOM 노드 객체에도 바인딩하여 사용하기도 함.
  - 이벤트 핸들러 어트리뷰트 방식은 결국 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 이벤트 핸들러 프로퍼티 방식과 동일하다고 볼 수 있음
  - 이벤트 핸들러 프로퍼티 방식은 이벤트 핸들러 어트리뷰트 방식의 HTML과 JS가 뒤섞이는 문제를 해결할 수 있음
  - 그러나 핸들러 프로퍼티 방식은 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있음.

- addEventListener 메서드 방식

  - `EventTarget.prototype.addEventListener('eventType', functionName, [, useCapture])`
  - 첫번째 매개변수에는 이벤트 타입을 전달함. on 접두사를 붙이지 않음
  - 두번째 매개변수에 이벤트 핸들러를 전달함
  - 세번째 매개변수에 이벤트를 캐치할 이벤트 전파 단계(캡처링 or 버블링)를 지정함. false or 생략하면 버블링 단계에서 이벤트를 캐치함. true면 캡처링 단계에서 이벤트를 캐치.
  - addEventListener 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있음. 등록된 순서로 호출됨.
  - 그러나 동일한 이벤트 핸들러를 중복 등록하면 하나의 이벤트 핸들러만 등록함.

### 이벤트 핸들러 제거

- `EventTarget.prototype.removeEventListener`
- addEventListener 메서드로 등록한 이벤트 핸들러를 제거함
- addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않음
- 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없음. 이벤트 핸들러를 제거하려면 핸들러의 참조를 변수나 자료구조에 저장하고 있어야함.
- 기명 이벤트 핸들러 내부에서 removeEventListener 메서드를 호출하여 이벤트 핸들러를 제거하는 것은 가능. 이 때 이벤트 핸들러는 1번만 호출됨.
- 기명 함수를 이벤트 핸들러로 등록할 수 없다면 arguments.callee를 사용할 수 있지만 코드 최적화를 방해하므로 strict mode에서는 사용 금지임.
- 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 removeEventListener 메서드로 제거할 수 없음. null 할당으로 지울 수 있음.

### 이벤트 객체

- 이벤트 발생하면 해당 이벤트 관련 정보를 담는 이벤트 객체가 동적으로 생성됨
- 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달되어 매개변수 e에 암묵적으로 할당됨
- 이벤트 객체를 전달받기 위해서는 이벤트 핸들러를 정의할 때 이벤트 객체를 전달받을 매개변수를 명시적으로 선언해야함.
- 매개변수의 이름은 정해져있지 않아 다른 이름을 써도 상관없음.
- 이벤트 핸들러 어트리뷰트 방식으로 이벤트 핸들러를 등록했으면 event를 통해 이벤트 객체를 전달 받을 수 있음. (다른 이름으로는 이벤트 객체를 전달받지 못함)
- 이벤트 핸들러 어트리뷰트 방식은 암묵적으로 이벤트 핸들러 함수를 만드는데 이때 첫번째 매개변수의 이름이 event이기 때문임.

- 이벤트 객체의 상속 구조

  - 이벤트가 발생하면 이벤트 타입에 따라 다양한 타입의 이벤트 객체가 생성됨.
  - 이벤트 객체의 상속구조를 보면 여러개의 생성자 함수가 있음을 볼 수 있음(40-4). 이벤트 발생시 암묵적으로 생성되는 이벤트 객체는 생성자 함수에 의해 생성된거임.
  - 생성된 이벤트 객체는 생성자 함수와 더불어 생성되는 프로토타입으로 구성된 프로토타입 체인의 일원이 됨.
  - Event 인터페이스에는 모든 이벤트 객체의 공통 프로퍼티가 정의되어 있고, 하위 인터페이스에는 이벤트 타입에 따라 고유한 프로퍼티가 정의되어 있음.

- 이벤트 객체의 공통 프로퍼티

  - Event 인터페이스의 이벤트 관련 프로퍼티는 모든 이벤트 객체가 상속받는 공통 프로퍼티임.
  - 공통 프로퍼티
    - `type`
      - 이벤트 타입
      - string
    - `target`
      - 이벤트를 발생시킨 DOM 요소
      - DOM 요소 노드
    - `currentTarget`
      - 이벤트 핸들러가 바인딩된 DOM 요소
      - DOM 요소 노드
    - `eventPhase`
      - 이벤트 전파단계
      - 0: 이벤트 없음, 1: 캡처링 단계, 2: 타깃 단계, 3: 버블링 단계
      - number
    - `bubbles`
      - 이벤트를 버블링으로 전파하는지 여부.
      - 특정 이벤트는 false로 버블링하지 않음(focus/blur, load/unload/abord/error, mouseenter/mouseleave)
      - boolean
    - `cancelable`
      - preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부.
      - 특정 이벤트는 false로 취소할 수 없음(focus/blur, load/unload/abort/ error, dblclick/mouseenter/mouseleave)
      - boolean
    - `defaultPrevented`
      - preventDefault 메서드를 호출하여 이벤트를 취소했는지 여부
      - boolean
    - `isTrusted`
      - 사용자의 행위에 의해 발생한 이벤트인지 여부
      - 메서드를 통해 인위적으로 발생시킨 이벤트인 경우 false
      - boolean
    - `timeStamp`
      - 이벤트가 발생한 시각
      - number

- 마우스 정보 취득

  - MouseEvent 타입의 이벤트 객체의 고유 프로퍼티
    - 마우스 포인터의 좌표 정보를 나타내는 프로퍼티: screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
    - 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button

- 키보드 정보 취득

  - KeyboardEvent 타입의 이벤트 객체의 교유 프로퍼티
    - altKey, ctrlKey, shiftKey, metaKey, key, keyCode
  - input 요소의 입력 필드에 한글을 입력하고 엔터 키를 누르면 keyup 이벤트 핸들러가 두번 호출됨. 이 문제는 keydown 이벤트를 캐치하게 하면 해결됨.

### 이벤트 전파

- DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됨. 이를 이벤트 전파라고 부름.
- 생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파됨.
- 전파과정
  - li 요소를 클릭하면 클릭 이벤트가 발생하여 클릭 이벤트 객체가 생성되고, li 요소가 이벤트 타깃이 됨.
  - 클릭 이벤트 객체는 window에서 시작해서 이벤트 타깃 방향으로 전파됨. (캡처링 단계. 상위 요소에서 하위 요소로 전파)
  - 이벤트 객체는 이벤트를 발생시킨 이벤트 타깃에 도달함. (타깃 단계. 이벤트가 이벤트 타깃에 도달)
  - 이벤트 객체는 이벤트 타깃에서 시작해서 window 방향으로 전파됨. (버블링 단계. 하위 요소에서 상위 요소로 전파)
- 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록된 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만 캐치할 수 있음
- addEventListner 메서드 방식은 타깃 단계, 버블링 단계, 캡처링 단계의 이벤트를 선별적으로 캐치할 수 있음.
- 캡처링 단계의 이벤트를 캐치하도록 설정하면 window에서 시작해서 이벤트 타깃 방향으로 전파되는 이벤트 객체를 캐치하여 상위 DOM 요소에도 캐치할 수 있음.
- 특정 이벤트들은 버블링을 통해 전파되지 않음. (focus/blur, load/unload/abort/error, mouseenter/mouseleave)
- 해당 이벤트들은 focusin/focusout, mouseover/mouseout으로 대체 가능함.

### 이벤트 위임

- 이벤트 위임은 여러개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말함.
- 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃이 개발자가 기대한 DOM 요소가 아닐 수도 있기에 타깃을 검사할 필요가 있음
- `Element.prototype.matches` 메서드를 통해 특정 노드를 탐색 가능한지 확인할 수 있음.
- 일반적으로 target 프로퍼티와 currentTarget 프로퍼티는 동일한 DOM 요소를 가리키지만 이벤트 위임을 할 경우 다른 DOM 요소를 가리킬 수 있음.
- 예제 40-32 참조

### DOM 요소의 기본 동작 조작

- DOM 요소의 기본 동작 중단

  - DOM 요소는 저마다 기본 동작이 있음. ex) a 요소를 클릭하면 href 어트리뷰트에 지정된 링크로 이동
  - 이벤트 객체의 preventDefault 메서드는 이러한 DOM 요소의 기본 동작을 중단시킴

- 이벤트 전파 방지

  - 이벤트 객체의 stopPropagation 메서드는 이벤트 전파를 중단시킴.
  - 주로 하위 DOM 요소의 이벤트를 개별적으로 처리하기 위해 이벤트의 전파를 중단시킴.

### 이벤트 핸들러 내부의 this

- 이벤트 핸들러 어트리뷰트 방식

  - 이벤트 핸들러 어트리뷰트 방식으로 호출되는 함수는 일반 함수이기에 해당 함수 내부의 this는 전역객체(window)를 가리킴
  - 그러나 이벤트 핸들러를 호출할 때 인수로 this를 전달하면 this는 이벤트를 바인딩한 DOM 요소를 가리킴.
  - 왜냐하면 인수로 전달한 this는 암묵적으로 생성된 이벤트 핸들러 내부의 this 이기 때문. (이벤트 핸들러 프로퍼티 방식과 동일함)

- 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

  - 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킴.
  - 클래스에서 이벤트 핸들러를 바인딩하는 경우 this에 주의해야함.
  - 클래스 내부의 메서드 내부의 this는 클래스가 생성할 인스턴스를 가리키지 않고 이벤트를 바인딩한 DOM 요소를 가리킴.
  - 메서드를 이벤트 핸들러로 바인딩할 때 bind 메서드를 사용해 this를 전달하여 클래스 내부의 메서드 내부의 this가 클래스가 생성할 인스턴스를 가리키도록 해야함.
  - 클래스 필드에 할당한 화살표 함수를 이벤트 핸들러로 등록하여 이벤트 핸들러 내부의 this가 인스턴스를 가리키도록할 수 있음. 이때 이벤트 핸들러는 프로토타입 메서드가 아닌 인스턴스 메서드가 됨.

### 이벤트 핸들러에 인수 전달

- 이벤트 핸들러 어트리뷰트 방법으로 인수를 전달할 수 있음
- 이벤트 핸들러 프로퍼티와 addEventListener 메서드는 인수를 전달할 수 없음
- 하지만 이벤트 핸들러내에 함수를 호출하게 하고, 호출한 함수에 인수를 넣을 수 있도록 하면 되긴함. (예제 40-45)

### 커스텀 이벤트

- 커스텀 이벤트 생성

  - 이벤트 객체는 Event, UIEvent, MouseEvent와 같은 이벤트 생성자 함수로 명시적으로 이벤트 객체를 임의의 이벤트 타입을 지정하여 생성할 수 있음
  - 개발자의 의도로 생성된 이벤트를 커스텀 이벤트라고 함.
  - 이벤트 생성자 함수의 첫번째 인수로 이벤트 타입을 나타내는 문자열을 전달함. 이벤트 타입은 기존 이벤트 타입을 작성할 수 있고, 새로운 타입을 만들 수 있음.
  - 생성된 커스텀 이벤트 객체는 bubbles와 cancelable 프로퍼티의 값이 false로 기본 설정됨
  - 두번째 인수로 bubbles 또는 cancelable 프로퍼티를 갖는 객체를 전달할 수 있음, 또한 고유의 프로퍼티 값을 지정할 수 있음. (예제 40-49)
  - 커스텀 이벤트는 isTrusted 프로퍼티의 값이 언제나 false임.

- 커스텀 이벤트 디스패치

  - 생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치 (이벤트를 발생시키는 행위)를 할 수 있음
  - dispatchEvent 메서드에 이벤트 객체를 인수로 전달하면서 호출하면 인수로 쩐달한 이벤트 타입의 이벤트가 발생함.
  - 일반적으로 이벤트 핸들러는 비동기 처리 방식으로 동작하지만 dispatchEvent 메서드는 동기 처리 방식으로 호출함.
  - 동기적으로 처리하기에 이벤트를 디스패치하기 이전에 커스텀 이벤트를 처리할 이벤트 핸들러를 등록해야함.
  - 기존 이벤트 타입이 아닌 새로운 이벤트 타입을 지정하여 이벤트 객체를 생성하는 경우 일반적으로 CustomeEvent 이벤트 생성자 함수를 사용함.
  - CustomEvent 두번째 인수로 이벤트와 함께 전달하고 싶은 정보를 담은 detail 프로퍼티를 포함하는 객체를 전달할 수 있음. 이 정보는 이벤트 객체의 detail 프로퍼티(e.detail)에 담겨 전달됨.
  - 기존 이벤트 타입이 아닌 임의의 이벤트 타입을 지정하여 커스텀 이벤트 객체를 생성한 경우 반드시 addEventListener 메서드 방식으로 이벤트 핸들러를 등록해야함.
  - 이벤트 핸들러 어트리뷰트/ 프로퍼티 방식을 사용할 수 없는 이유는 on + 이벤트 타입으로 이루어진 이벤트 핸들러 어트리뷰트/프로퍼티가 요소 노드에 존재하지 않기 때문.

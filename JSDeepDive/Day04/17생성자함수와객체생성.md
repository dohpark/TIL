## 생성자 함수에 의한 객체 생성

### Object 생성자 함수

- new Object(); new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환함.
- 생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수
- 생성자 함수로 생성한 객체를 인스턴스라고 함.
- Object 생성자 함수 외에 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등이 있음.
- Object 생성자 함수를 사용해 객체를 생성한 방식은 특별한 이유가 없다면 리터럴이 더 편할 것.

### 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식의 문제점

  - 객체 리터럴은 한개의 객체만을 생성하기에, 구조적으로 같은 객체를 여러개 생성하고자 하면 객체 리터럴로는 매우 비효율적임

- 생성자 함수에 의한 객체 생성 방식의 장점

  - 생성자 함수에 의한 객체 생성 방식은 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러개를 간편하게 생성할 수 있음.
  - 생성자 함수는 객체(인스턴스)를 생성하는 함수임. 그런데 자바와 같이 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의함.
  - new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작하고, new 연산자 없이 호출하면 일반 함수로 동작함.

- 생성자 함수의 인스턴스 생성 과정

  - 1 인스턴스 생성과 this 바인딩
    - 함수 몸체 코드 실행 되는 런타임 이전에
    - 암묵적으로 빈 객체(인스턴스)가 생성됨.
    - 빈 객체(인스턴스)는 this에 바인딩 됨.
  - 2 인스턴스 초기화
    - 코드가 실행되며 this에 바인딩되어 있는 인스턴스를 초기화함.
    - 인스턴스에 프로퍼티나 메서드를 추가하고, 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당함.
  - 3 인스턴스 반환
    - 생성자 함수의 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환함.
    - 만약에 명시적으로 다른 객체를 반환하도록 작성하면 그 다른 객체를 반환함. return {} 작성시 {}를 반환함.
    - 만약에 명시적으로 원시값을 반환하도록 작성하면 무시되고 this를 반환함.
    - 그러므로 생성자 함수 내부에서 return문을 생략하자.

- 내부 메서드 `[[Call]]`과 `[[Construct]]`

  - 함수는 객체이기에 일반 객체가 지니는 내부 슬롯과 내부 메서드를 모두 갖고 있음.
  - 추가적으로 함수 객체는 `[[environment]]`, `[[formalParameters]]`등의 내부 슬롯과 `[[call]]`, `[[constructor]]`같은 내부 메서드를 갖고 있음.
  - 일반 함수로 호출되면 `[[call]]`이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 `[[construct]]`가 호출됨.
  - 모든 함수는 호출이 가능하기에 `[[call]]` 내부 메서드를 지니고 있음. `[[call]]` 내부 메서드를 지닌 함수 객체를 callable이라고 함.
  - 모든 함수 객체는 `[[constructor]]`을 갖고 있지 않음. 해당 내부 메서드를 지니면 constructor, 없으면 non-constructor이라고 부름.

- constructor와 non-consctructor의 구분

  - JS엔진은 함수 정의 방식에 따라 함수를 constructor와 non-constructor로 구분함.

    - constructor: 함수 선언문, 함수 표현식, 클래스
    - non-constructor: 메서드(es6 메서드 축약 표현), 화살표 함수

  - ecmascript 사양에서 메서드란 es6의 메서드 축약 표현만을 의미함.
  - 함수가 어디에 할당되어 있는지에 판단하는 것이 아닌 함수 정의 방식에 따라 constructor과 non-constructor을 구분.
  - 주의할 것은 일반 함수(생성자 함수로 쓸 생각이 없는 함수)에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것.

- new 연산자

  - new 연산자와 함께 호출하면 내부 메서드 `[[constructor]]`이 호출되어 생성자 함수로 동작함
  - new 연산자와 없이 호출하면 내부 메서드 `[[call]]`이 호출되어 일반 함수로 동작함.
  - new 연산자와 없이 호출하면 해당 함수의 this는 전역 객체 window를 가리키게 되어, 전역객체의 프로퍼티와 메서드를 만들 수가 있음.
  - 이를 방지하기 위해 생성자 함수는 파스칼 케이스(첫 문자를 대문자로 기술)로 일반 함수와 구별함.

- new.target

  - es6부터 new.target을 지원함. (ie는 new.target을 지원하지 않음)
  - new.target 사용 시 일반 함수로서 호출되면 함수 내부의 new.target은 undefined임.
  - 생성자 함수로 호출되면 new.target은 함수 자신을 가리킴.
  - 생성자 함수와 객체(생성자 함수를 통해 생성한 객체. 인스턴스)는 프로토타입에 의해 연결되어 있어 이를 통해 new 연산자로 호출되었는지도 확인 가능함.
  - 빌트인 생성자 함수 중 Object와 Function은 new 유무 상관없이 동일하게 동작함.
  - String, Number, Boolean 생성자 함수는 new연산자로 호출 시 객체를 반환하고, new 연산자 없시 호출하면ㄴ 문자열, 숫자, 불리언 값을 반환함. 이를 통해 타입 변환하기도 함.

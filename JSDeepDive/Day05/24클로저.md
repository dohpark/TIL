## 클로저

### 렉시컬 스코프

- js엔진은 함수를 어디서 호출했는지가 아닌 함수를 어디서 정의했는지에 따라 상위 스코프를 결정함.
- 스코프는 실행 컨텍스트의 렉시컬 환경으로, 외부 렉시컬 환경에 대한 참조(Outer Lexical Envrionment Reference)를 통해 상위 렉시컬 환경과 연결됨.
- 이렇게 연결되며 이루어진 렉시컬 환경들을 총체적으로 스코프 체인이라고 함.
- 렉시컬 스코프는 함수 정의가 평가되는 시점에 함수가 정의된 환경(스코프)에 의해 상위 스코프가 결정이 됨.

### 함수 객체의 내부 슬롯 `[[environment]]`

- 함수는 정의되어 생성될 때와 호출될 때의 스코프가 다를 수 있음. 함수의 상위 스코프는 함수가 정의되어 생성됐을 때 결정된다고 볼 수 있음.
- 함수는 자신의 내부 슬롯 `[[environment]]`에 자신이 정의된 환경을 저장함. 즉 함수가 정의 될때 실행 중인 실행 컨텍스트의 렉시컬 환경을 저장함.
- 함수 객체의 내부 슬롯 `[[environment]]`에 저장된 참조가 바로 상위 스코프라고 볼 수 있음.
- 왜냐하면 함수가 호출 되었을 때 외부 렉시컬 환경에 대한 참조에 함수 객체의 내부 슬롯 `[[environment]]`에 저장된 참조를 할당하기 때문.
- 즉 상위 스코프는 함수 자체의 존재와 함께 생성된거이기에 동적으로 변할 수 없음.

### 클로저와 렉시컬 환경

- 외부 함수보다 중첩 함수가 더 왤 유지되는 경우 중첩 함수는 이미 생명주기가 종료한 외부 함수의 변수를 참조할 때, 이런 중첩 함수를 클로저라고 부름
- outer 함수의 실행 컨텍스트는 실행 컨텍스 스택에서 제거되어도 outer 함수의 렉시컬 환경까지 소멸 안할 수 있음.
- 왜냐하면 다른 변수에 의해 참조되고 있다면 가비지 컬렉션의 대상이 되지 않기 때문임
- 또한, inner 함수 객체의 `[[environment]]`를 통해 상위 스코프를 참조할 수 있기에, inner 함수 실행 시 `[[environment]]` 내부 슬롯에 저장되어 있는 참조값이 외부 렉시컬 환경에 대한 참조에 할당됨.
- js의 모든 함수는 상위 스코프를 기억하기에 이론적으로 모든 함수는 클로저지만, 주로 외부함수보다 중첩 함수가 더 오래 유지되어 중첩함수가 이미 생명주기가 종료한 외부 함수의 변수를 참조할때, 이런 중첩 함수를 클로저라고 함.
- 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 부름.
- 클로저의 메모리 점유는 필요한 것을 기억하기 위한 것이므로 불필ㄹ요한 메모리 낭비로 볼 수 없음.

### 클로저의 활용

- 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용됨. 상태를 안전하게 은닉하고 특정 함수로만 해당 삳태를 변경을 허용하기 위해 클로저를 사용할 수 있음
- 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 안정성을 높이기 위해 클로저를 적극적으로 사용함.
- 예제 24-14. 고차함수와 클로저

### 캡슐화와 정보 은닉

- 캡슐화는 프로퍼티와 메서드를 하나로 묶는 것임. 캡슐화를 통해 프로퍼티나 메서드를 감추는 목적으로 사용하는데 이를 정보 은닉이라고 함.
- 자바스크립트의 객체는 기본적으로 외부에 공개되어 있는데 이를 클로저를 통해 감출 수 있음
- 방법1 변수를 this.age가 아닌 `_.age`로 할당하여 생성자 함수로 생성하면 `._age` 변수는 외부에서 참조하거나 변경이 불가능하기에 private함.
- 방법1 단점. 생성자 함수로 객체 생성 시 중복 생성될 수 있음
- 방법2 프로토타입 메서드를 추가한 후 클로저로 만들어보자
- 방법2 단점. 해당 생성자 함수로 만든 객체들은 `._age` 변수를 같이 참조할 수 있게 되어 문제가 생김.
- 방법2는 클래스에 private 필드를 정의할 수 있는 새로운 표준 사양이 제안되어 있고, chrome74와 node.js 버전12 이상에 이미 구현되어 있어서 그걸로 대안이 될 듯.

### 자주 발생하는 실수

- 예제 24-20.

## this

### this 키워드

- 객체는 프로퍼티(상태)와 메서드(동작)을 하나의 논리적인 단위로 묶은 복합적인 자료구조임.
- 메서드 사용 시 프로퍼티를 참조하고 변경할 수 있어야 하는데, 자신이 속한 객체의 프로퍼티를 참조하기 위해서는 자신이 속한 객체를 가리키는 식별자를 참조 가능해야함.
- 자신이 속한 재귀적으로 참조가 가능하지만 일반적이지 않으며 바람직하지 않음.
- 생성자 함수로 인스턴스를 생성하기 위해서는 먼저 생성자 함수가 존재해야함. 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성 전이기에 생성자 함수가 생성할 인스턴스를 가리키는 식별자가 없음. 그렇기 때문에 자신이 속한 객체 혹은 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요한데, 그게 this라는 식별자임.
- this는 자신이 속한 객체 or 자신이 생성할 인스턴ㄴ스를 기리키는 자기참조변수(self-referencing variable)임.
- this 바인딩은 함수 호출 방식에 의해 동적으로 결정됨.
- 객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 자신이 속한 객체를 가리킴
- 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킴.
- strict mode에서 일반함수 내부의 this는 undefined가 바인딩됨. 일반 함수 내부에서 this를 사용할 필요가 없기 때문임.

### 함수 호출 방식과 this 바인딩

- 일반 함수 호출

  - 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩됨.
  - this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반함수에서는 this가 의미없기에, strict mode에서는 일반함수 내부의 this는 undefined가 바인딩 됨.
  - 일반함수로 호출된 모든 함수(중첩, 콜백 등)는 내부의 this에 전역 객체 바인딩됨.
  - 문제점: 메서드 내에서 정의한 중첩 함수 or 메서드에게 전달한 콜백 함수가 일반함수로 호출 시 메서드 내의 중첩함수 또는 콜백함수의 this가 전역 객체를 바인딩 함.
  - 해결1: 이를 일치시키기 위해서 this 바인딩을 다른 변수에 할당해서 참조하게 하는 방법이 있음
  - 해결2: this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메서드를 사용
  - 해결3: 화살표 함수를 사용해서 this 바인딩을 일치시키는 방법

- 메서드 호출

  - 메서드 내부의 this에는 메서드를 호출한 객체가 바인딩이 됨. (메서드를 소유한 객체가 아닌)
  - 객체 내의 메서드는 사실 해당 객체에 포함된 것이 아닌 독립적으로 존재하는 별도의 객체임. 다만 해당 객체의 프로퍼티가 함수 객체를 가리키고 있을 뿐.
  - 그렇기에 다른 객체의 프로퍼티에 할당하면 다른 객체의 메서드가 될 수 있으며, 일반 변수에 할당하면 일반함수로 호출이 가능함. (일반 변수에 할당하여 호출하면 this는 전역객체를 가르키게 됨.)
  - 결론적으로 메서드 내부의 this는 프로퍼티 메서드를 가리키고 있는 객체와 상관이 없으며, 메서드를 호출한 객체에 바인딩이 됨.

- 생성자 함수 호출

  - 생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩됨.

- Function.prototype.apply/call/bind 메서드에 의한 간접 호출

  - apply, call, bind 메서드는 Function.prototype의 메서드임. 이들 메서드는 모든 함수가 상속받아 사용할 수 있음.

  - apply, call 메서드

    - apply와 call의 첫번째 매개변수에는 this로 사용할 객체를 넘김. 두번째 매개변수는 함수에게 전달할 인수 리스트 혹은 인수리스트의 배열 or 유사배열객체
    - 둘 다 return 값으로 호출된 함수의 반환값을 줌. 즉 본질적인 기능은 함수를 호출하는 것.
    - apply와 call 메서드는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하게 도와줄 수 있음. (arguments 객체는 배열이 아니기에 배열 메서드 사용이 불가함)
    - ex) const arr = Array.prototype.slice.call(arguments)

  - bind 메서드

    - Function.prototype.bind 메서드는 함수를 호출하지 않고 this로 사용할 객체만 전달함.
    - this가 불일치하는 문제를 bind를 통해 문제를 해결할 수 있음.

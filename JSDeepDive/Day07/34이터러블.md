## 이터러블

### 이터레이션 프로토콜

- 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙임
- ES5 이전은 통일된 규약 없이 각자 나름의 구조를 가지고 다양한 방법으로 순횐했음 (for문, for ...in문, forEach 메서드)
- ES6에서 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 일원화함 (for... of문, 스프레드문법, 디스트럭처링 할당)
- 이터레이션 프로토콜은 이터러블 프로토콜과 이터레이터 프로토콜이 있음

- 이터러블 프로토콜

  - Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환함.
  - 이런 규약을 이터러블 프로토콜이라고 하며, 이터러블 프로토콜을 준수한 객체를 이터러블이라고 함.
  - 이터러블은 for... of문, 스프레드 문법, 배열 디스털처링 할당 등으로 사용 가능함.
  - 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이기 for ...of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용가능함.
  - 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니기에 for ...of 문, 스프레드 문법, 배열 디스트럭처링을 사용 못함
  - 그러나 현재 TC39의 stage 4 단계에 일반객체에 스프레드 문법의 사용을 허용함.

- 이터레이터 프로토콜

  - Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환함.
  - 이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환함.
  - 이러한 규약을 이터레이터 프로토콜이라고 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라고 함. 이터레이터는 이터러블의 요소를 탐색하기 위한 포인터 역할을 함.

### 빌트인 이터러블

- Array, String, Map, Set, TypedArray, arguments, DOM 컬렉션은 이터레이션 프로토콜을 준수한 객체임

### for ... of 문

- for ...in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 true인 프로퍼티를 순회하며 열거함. 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않음.
- for ...of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for... of문의 변수에 할당함
- 이터레이터 리절트 객체의 done 프로퍼티 값이 false이면 이터러블의 순회를 계속하고 true이면 이터러블의 순회를 중단함.

### 이터러블과 유사 배열 객체

- 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체임.
- length 프로퍼티를 갖기 때문에 for문으로 순회 가능하고, 인덱스를 프로퍼티 키로 가지기에 배열처럼 인덱스로 프로퍼티 값에 접근 가능함.
- 유사 배열 객체는 System.iterator 메서드가 없기에 이터르블이 아닌 일반 객체임.
- 단, arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블임.

### 이터레이션 프로토콜의 필요성

- ES5 이전의 순회 가능한 데이터 컬렉션은 통일된 규약 없이 각자 나름의 구조를 가지고 다양한 방법으로 순회할 수 있었음
- ES6에서 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일했음
- 왜냐하면 데이터 공급자가 각자 순회 방식을 갖는다면 데이터 소비자는 다양한 공급자의 순회 방식을 모두 지원해야하므로 비효율적이기 때문임.
- 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 됨.
- 이처럼 데이터 프로토콜은 데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 함.

### 사용자 정의 이터러블

- 사용자 정의 이터러블 구현

  - 일반 객체도 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 됨.
  - Symbol.iterator 메서드를 구현하고 Symbol.iterator 메서드가 next 메서드를 갖는 이터레이터를 반환하도록 해야함
  - 이터레이터의 next 메서드는 done과 value 프로퍼티를 가지는 이터레이터 리절트 객체를 반환해야함.
  - for ... of 문은 done 프로퍼티가 true가 될때까지 반복함.

- 이터러블을 생성하는 함수

  - 이터러블을 반환하도록 하면 됨
  - 예제 34-14, 34-15 참고

- 이터러블이면서 이터레이터인 객체를 생성하는 함수

  - 이터러블이면서 이터레이터인 객체를 생성하면 Symbol.iterator 메서드를 호출하지 않아도 됨 (예제 34-15 참고)
  - 해당 객체의 Symbol.iterator 메서드가 this를 반환하는 메서드를 지니고, next 메서드를 갖도록 하면 자연스롭게 next 메서드를 갖는 이터레이터를 반환함.
  - 예제 34-16, 34-17 참고

- 무한 이터러블과 지연 평가

  - 이터러블이면서 이터레이터인 객체를 생성하는 함수를 통해 지연평가를 통해 데이터를 생성하는 이터러블을 만들 수 있음.
  - 지연 평가란 데이터가 필요한 시점 이전까지 미리 데이터를 생성하지 않다가 데이터가 필요한 시점이 되면 그때야 비로소 데이터를 생성하는 기법임.
  - 지연평가란 평가 결과가 필요할 때까지 평가를 늦추는 기법임
  - 불필요한 데이터를 미리 생성하지 않기에 빠른 실행 속도를 기대할 수 있고, 불푤요한 메모리를 소비하지 않고, 무한도 표현할 수 있음.

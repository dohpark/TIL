## GraphQL is the better REST

- 지난 10년간 REST는 web API 디자인에서의 기준이 되었음. 무상태 서버, 리소스로의 구조적 접근 등의 좋은 아이디어를 제공했으나, 클라이언트의 요구의 끊임 없는 변화에는 유연하게 대처하고 있지 못하고 있음.
- GraphQL은 유연성과 효율성을 더 높이기 위해 개발되었으며, REST API의 단점들을 해결함.
- REST와 GraphQL의 가장 큰 차이점은 API에서 데이터를 fetch할 때 나타남. 예를 들어 블로그 어플에서 특정한 사용자의 블로그 포스트들의 제목들을 나타내야함. 동시에 유저를 최근에 팔로우한 3명를 나타내야함. GraphQL과 REST는 어떻게 이를 해결할 것인가...?

### Data Fetching with REST vs GraphQL

- REST API 사용하는 경우 일반적으로 다양한 엔드포인트에 접근하여 데이터를 모았을 것임. 유저 데이터를 받기 위해 `/users/<id>` 엔드포인트, 해당 유저의 포스트에는 `/users/<id>/posts` 엔드포인트, 유저의 팔로워들의 리스트에는 `/users/<id>/followewrs` 엔드포인트를 사용했을 거임
- GraphQL은 하나의 쿼리를 GraphQL 서버에 전송하여 원하는 데이터들을 얻을 수 있음. 서버는 JSON 오브젝트로 응답을 보내 줄것임

- 요청으로 아래와 같은 쿼리를 GraphQL 서버에 전송하면

```js
query {
  User(id: "er3tg439frjw)" {
    name
    posts {
      title
    }
    followers(last: 3) {
      name
    }
  }
}
```

- 응답으로 아래와 같은 JSON 오브젝트를 받음

```js
{
  "data": {
    "User": {
      "name": "Mary",
      "posts": [
        { title: "Learn GraphQL" }
      ],
      "followers": [
        { name: "John" },
        { name: "Alice" },
        { name: "Sarah" },
      ]
    }
  }
}
```

### No more Over- and Underfetching

- REST의 문제점 중 overfetching과 underfetching임. 이 것이 발생하는 원인은 클라이언트가 엔드포인트에서 구조적으로 고정된 데이터를 받기 때문임. 그렇기에 클라이언트가 필요한 데이터만 전달하기만으로 디자인하기에 매우 어려움.

#### Overfetching: Downloading superfluous data

- overfetching은 클라이언트가 필요 이상의 데이터를 다운받는다는 것임. 만약에 유저의 이름만 데이터로 받아오고 싶으면, REST API에서는 `/users` 엔드 포인트를 통해 생일, 주소 등을 포함하는 데이터들을 다 받아서 사용하는 경우가 많음

#### Underfetching and the n+1 problem

- 다른 문제점은 underfetching과 n+1-요청 문젲임. underfecthing은 보통 특정 엔드포인트만으로 필요한 정보를 충족하지 못할 때를 말함. 클라이언트는 추가적인 요청을 하여 필요한 부분을 보충해야함. 이는 클라이언트가 요소의 리스트를 먼저 다운받은 후에, 해당 리스트의 요소별로 다시 필요한 데이터를 fetch하는 경우로 번질 수 있음.

### Rapid Product Iterations on the Frontend

- REST API의 일반적인 패턴은 앱 내부의 뷰에 따라 엔드포인트를 구성하는 것임. 이는 클라이언트가 해당 엔드포인트에 접근하기만 하면 특정 뷰에 필요한 모든 정보를 얻을 수 있기 때문에 편리함.
- 이 접근법의 가장 큰 단점은 프런트 엔드에서 빠른 이터레이션을 허용하지 않는다는 것임. UI를 변경할 때마다 이전보다 더 많은(또는 더 적은) 데이터가 필요할 위험이 높음. 따라서 새로운 데이터 요구를 고려하여 백엔드도 조정해야 함. 이로 인해 생산성이 저하되고 사용자 피드백을 제품에 반영하는 기능이 저하함.
- GraphQL을 사용하면 이 문제가 해결됨. GraphQL의 유연한 특성 덕분에 서버에서 별도의 작업 없이 클라이언트 측에서 변경이 가능함. 클라이언트는 정확한 데이터 요구사항을 지정할 수 있으므로 프런트엔드에서 설계 및 데이터 요구사항을 변경할 때 백엔드 엔지니어가 조정할 필요가 없음.

### Insightful Analytics on the Backend

- GraphQL을 사용하면 백엔드로 요청된 데이터에 대한 세부적인 통찰력을 얻을 수 있음. 각 클라이언트가 필요한 정보를 정확히 명시하기 때문에 데이터가 어떻게 사용되고 있는지에 대한 이해도를 높일 수 있음. 예를 들어, API를 발전시키고 클라이언트가 더 이상 요청하지 않는 특정 필드를 deprecate 하는데데 도움이 될 수 있음.
- GraphQL을 사용하면 서버가 처리하는 요청에 대한 낮은 수준의 성능 모니터링을 수행할 수 있음. GraphQL은 리졸버 함수의 개념을 사용하여 클라이언트가 요청한 데이터를 수집함. 이러한 리졸버의 성능을 계측하고 측정하면 시스템의 병목 현상(bottleneck)에 대한 중요한 통찰력을 얻을 수 있음.

### Benefits of a Schema & Type System

- GraphQL은 강력한 타입 시스템을 사용하여 API의 기능을 정의함. API에 표시되는 모든 유형은 GraphQL Schema Definition Language(SDL)를 사용한 스키마에 기록됨. 이 스키마는 클라이언트와 서버 간의 계약 역할을 하여 클라이언트가 데이터에 접근할 수 있는 방법을 정의함.
- 스키마가 정의되면 프론트엔드와 백엔드는 더 이상의 커뮤니케이션 필요업ㅂㅅ이 자신의 일을 하면 됨. 왜냐하면 둘 모두 네트워크를 통해 전달되는 확고한 데이터의 구조를 알 수 있기 때문임.
- 프론트엔드팀은 필요한 데이터 구조를 바탕으로 가짜 데이터를 생성하여 쉽게 테스트할 수 있음. 서버가 준비되면 클라이언트 앱이 실제 API에서 데이터를 로드하도록 할 수 있음.

## Clients

- 프론트엔드에서 GraphQL API로 작업하는 것은 새로운 추상화를 개발하고 클라이언트 측에서 공통 기능을 구현하는 데 도움이 됨. 앱에 포함하고 싶은 몇 가지 "인프라" 기능을 고려해 보겠음.

  - HTTP 요청 구현 없이 쿼리와 mutations 바로 전송하기
  - 뷰 레이어 통합
  - 캐싱
  - 스키마 바탕으로 쿼리 검증 및 최적화

- 기본 HTTP를 사용하여 데이터를 fetch해도 되긴함. 근데 그큐엘은 수동적으로 해야하는 일을 추상화하여 앱에서 진짜 중요한 일에 집중할 수 있도록 도와줌.
  - 현재 가장 큰 두가지 그큐엘 클라이언트가 있음. 첫번째는 Apollo Client임. 아폴로 클라이언트는 모든 주요 개발 플랫폼에서 사용할 수 있는 강력하고 유연한 그큐엘 클라이언트임. 두번째는 Relay임. 웹에서만 사용할 수 있고 퍼프먼스를 최적화에 강력함

### Send Queries and Mutations Directly

- 그큐엘의 장점 중 하나는 명시적인 방법으로 데이터를 가져오거나 업데이트할 수 있다는 점임. 다른말로, API 추상화 사다리를 타고 한단계 올라가 낮은 레벨의 네트워크 태스크를 더이상 손대지 않아도 됨.
- 그큐엘에서 쿼리를 통해 데이터 요구사항들을 선언하고 나머지 요청과 응답은 시스템이 알아서 처리하도록 할 수 있음. 이는 그큐엘 클라이언트가 봐줌.

### View Layer Integrations & UI updates

- 서버 응답이 그큐엘 클라이언트로 받고 처리해도 요청한 데이터를 UI 상에 나타내도록 해야함. 이는 플랫폼 및 프레임워크에 따라 다양한 방법을 통해 UI를 업데이트 함.
- 리액트를 예로 들자면 그큐엘 클라이언트는 higher-order components 개념을 활용하여 필요한 데이터를 가져오고 컴포넌트의 props에 사용할 수 있도록 함. 일반적으로 그큐엘의 선언적 특성은 functional reactive programming과 잘 맞음. 이 두 가지는 뷰가 단순히 데이터 종속성을 선언하고 UI가 선택한 FRP 레이어와 연결할 수 있는 조합을 형성함.

### Caching Query Results: Concepts and Strategies

- 대부분의 어플리케이션엔 기존의 데이터에서 가져온 데이터의 캐시를 유지하길 원함.
- 일반적으로 캐싱을 통해 원격으로 가져온 정보를 나중에 검색할 수 있는 로컬 저장소에 넣는 것임. 그큐엘을 사용하면 단순하게 그큐엘 쿼리 결과를 저장소에 넣고 동일한 쿼리가 전송될 때마다 단순히 반환함. 이 접근 방식은 대부분의 응용 프로그램에서 비효율적임.
- 더 효율적인 접근법은 데이터를 이전에 정규화하는 것임. 이는 중첩된 쿼리 결과가 평면화되고 저장소에 전역적으로 고유한 ID로 참조할 수 있는 개별 레코드가 포함되는 것임. 이에 대해 더 알고 싶다면 [Apollo 블로그](https://www.apollographql.com/blog/graphql/basics/the-concepts-of-graphql/) 참고

### Build-time Schema Validation & Optimizations

- 스키마에는 클라이언트가 그큐엘 api를 통해 어떤 데이터를 사용할 수 있는지에 대한 정보를 다 지니기기 때문에, 빌드타임 때 클라이언트가 전송하고자 하는 쿼리들을 검증하고 최적화할 수 있음.
- 빌드환경이 스키마에 접근이 가능하면 프로젝트 내의 모든 그큐엘 코드를 파싱하고 스키마의 정보와 비교할 수 있음. 이는 어플리케이션이 실제로 사용되기 전에 타입 에러와 같은 다양한 에러들을 잡을 수 있음.

### Colocating Views and Data Dependencies

- 그큐엘을 통해 UI 코드와 데이터 요구 사항을 나란히 가질 수 있음. 그 덕에 원하는 데이터를 어떻게 알맞는 UI 부분에 넣을지에 대한 고민을 줄일 수 있음
- colocation은 어느 플랫폼에 개발하늕지에 따라 다름. 예를 들어 js 어플리케이션에는 데이터 종속성과 ui 코드를 하나의 파일에 넣을 수 있음.
